library(shiny)
library(shinythemes)
library(plotly)
library(quantmod)
library(rugarch)
library(caret)
library(zoo)

# UI Section
ui <- fluidPage(
  theme = shinytheme("darkly"),
  titlePanel("Financial Modeling Dashboard"),
  
  sidebarLayout(
    sidebarPanel(
      textInput("ticker", "Stock Ticker (e.g., AAPL):", value = "AAPL"),
      dateRangeInput("daterange", "Date Range:", 
                     start = Sys.Date() - 365, end = Sys.Date()),
      numericInput("alpha", "GARCH Alpha (α):", value = 0.1, step = 0.01),
      numericInput("beta", "GARCH Beta (β):", value = 0.8, step = 0.01),
      numericInput("k", "Max K for RMSE Plot:", value = 10, min = 1, step = 1),
      actionButton("analyze", "Analyze"),
      br(),
      h3("Outputs:"),
      verbatimTextOutput("modelSummary"),
      textOutput("varResult"),
      textOutput("sharpeRatioResult"),
      textOutput("optionPrice")
    ),
    
    mainPanel(
      tabsetPanel(
        tabPanel("GARCH Forecast", plotlyOutput("garchForecastPlot")),
        tabPanel("Rolling Volatility", plotlyOutput("rollingVolatilityPlot")),
        tabPanel("Stock Price Forecast", plotlyOutput("forecastPlot")),
        tabPanel("RMSE vs K", plotlyOutput("rmsePlot")),
        tabPanel("Volatility Overlay", plotlyOutput("volatilityPlot"))
      )
    )
  )
)

# Server Section
server <- function(input, output, session) {
  # (Your server code remains unchanged and is included here as written in the question)
}

# Run the Application
shinyApp(ui = ui, server = server)



# Server Section
server <- function(input, output, session) {
  # Fetch Stock Data
  stockData <- eventReactive(input$analyze, {
    req(input$ticker, input$daterange)
    tryCatch({
      data <- getSymbols(input$ticker, src = "yahoo",
                         from = input$daterange[1],
                         to = input$daterange[2],
                         auto.assign = FALSE)
      na.omit(data)
    }, error = function(e) {
      showNotification("Failed to fetch stock data. Please check the ticker or date range.", type = "error")
      NULL
    })
  })
  
  # GARCH Model
  garchModel <- reactive({
    req(stockData(), input$alpha, input$beta)
    returns <- na.omit(diff(log(Cl(stockData()))))
    
    spec <- ugarchspec(
      variance.model = list(model = "sGARCH", garchOrder = c(1, 1)),
      mean.model = list(armaOrder = c(0, 0)),
      distribution.model = "norm"
    )
    
    spec@model$variance$model$alpha1 <- input$alpha
    spec@model$variance$model$beta1 <- input$beta
    
    tryCatch({
      ugarchfit(spec = spec, data = returns)
    }, error = function(e) {
      showNotification("GARCH model fitting failed. Check your data or parameter values.", type = "error")
      NULL
    })
  })
  
  # GARCH Model Summary
  output$modelSummary <- renderPrint({
    fit <- garchModel()
    if (is.null(fit)) {
      cat("GARCH model fitting failed.\n")
    } else {
      cat("GARCH Model Summary:\n")
      print(fit)
    }
  })
  
  # GARCH Forecast Plot
  output$garchForecastPlot <- renderPlotly({
    req(garchModel())
    fit <- garchModel()
    forecast <- ugarchforecast(fit, n.ahead = 30)
    vol_forecast <- sigma(forecast)^2
    plot_ly(x = 1:30, y = vol_forecast, type = "scatter", mode = "lines", name = "GARCH Forecast") %>%
      layout(title = "GARCH Variance Forecast", xaxis = list(title = "Days Ahead"), yaxis = list(title = "Variance"))
  })
  
  # Rolling Volatility Plot
  output$rollingVolatilityPlot <- renderPlotly({
    req(stockData())
    returns <- na.omit(diff(log(Cl(stockData()))))
    rolling_volatility <- rollapply(returns, width = 30, FUN = sd, align = "right", fill = NA)
    plot_ly(x = index(stockData())[31:length(returns)], y = rolling_volatility[31:length(returns)],
            type = "scatter", mode = "lines", name = "Rolling Volatility") %>%
      layout(title = "Rolling Volatility (30-Day)", xaxis = list(title = "Date"), yaxis = list(title = "Volatility"))
  })
  
  # Stock Price Forecast
  output$forecastPlot <- renderPlotly({
    req(stockData(), garchModel())
    fit <- garchModel()
    forecast <- ugarchforecast(fit, n.ahead = 30)
    vol_forecast <- sigma(forecast)
    last_close <- as.numeric(tail(Cl(stockData()), 1))
    forecast_prices <- last_close * exp(cumsum(rnorm(30, mean = 0, sd = vol_forecast)))
    plot_ly(x = 1:30, y = forecast_prices, type = "scatter", mode = "lines", name = "Stock Price Forecast") %>%
      layout(title = "Stock Price Forecast (30 Days)", xaxis = list(title = "Days Ahead"), yaxis = list(title = "Price"))
  })
  
  # RMSE vs K Plot
  output$rmsePlot <- renderPlotly({
    req(stockData())
    returns <- na.omit(diff(log(Cl(stockData()))))
    set.seed(42)
    trainIndex <- createDataPartition(returns, p = 0.8, list = FALSE)
    train <- returns[trainIndex]
    test <- returns[-trainIndex]
    
    rmse_values <- sapply(1:input$k, function(k) {
      model <- knn.reg(train = train, test = test, y = train, k = k)
      sqrt(mean((model$pred - test)^2))
    })
    plot_ly(x = 1:input$k, y = rmse_values, type = "scatter", mode = "lines", name = "RMSE vs K") %>%
      layout(title = "RMSE vs K for K-NN", xaxis = list(title = "Number of Neighbors (K)"), yaxis = list(title = "RMSE"))
  })
  
  # Volatility Overlay Plot
  output$volatilityPlot <- renderPlotly({
    req(stockData(), garchVariance())
    dates <- index(stockData())
    volatility <- garchVariance()
    plot_ly(x = dates, y = volatility, type = "scatter", mode = "lines", name = "Predicted Volatility") %>%
      layout(title = "Volatility Overlay Plot", xaxis = list(title = "Date"), yaxis = list(title = "Volatility"))
  })
  
  # GARCH Variance
  garchVariance <- reactive({
    fit <- garchModel()
    if (!is.null(fit)) sigma(fit)^2 else NULL
  })
  
  # Calculate VaR
  calculateVaR <- reactive({
    req(garchVariance())
    volatility <- sqrt(mean(garchVariance()))
    quantile_95 <- -qnorm(0.05) * volatility
    quantile_95
  })
  
  # Calculate Sharpe Ratio
  calculateSharpeRatio <- reactive({
    req(stockData())
    returns <- na.omit(diff(log(Cl(stockData()))))
    risk_free_rate <- 0.02
    daily_risk_free <- risk_free_rate / 252
    excess_returns <- returns - daily_risk_free
    mean_excess <- mean(excess_returns)
    volatility <- sd(excess_returns)
    sharpe_ratio <- mean_excess / volatility
    sharpe_ratio
  })
  
  # Black-Scholes Option Pricing
  blackScholesPrice <- reactive({
    req(garchVariance())
    S <- 100
    K <- 105
    T <- 30 / 365
    r <- 0.02
    sigma <- sqrt(mean(garchVariance()))
    d1 <- (log(S / K) + (r + 0.5 * sigma^2) * T) / (sigma * sqrt(T))
    d2 <- d1 - sigma * sqrt(T)
    price <- S * pnorm(d1) - K * exp(-r * T) * pnorm(d2)
    price
  })
  
  # Outputs
  output$varResult <- renderText({
    req(calculateVaR())
    paste("1-day VaR (95% confidence):", round(calculateVaR(), 4))
  })
  
  output$sharpeRatioResult <- renderText({
    req(calculateSharpeRatio())
    paste("Sharpe Ratio:", round(calculateSharpeRatio(), 2))
  })
  
  output$optionPrice <- renderText({
    req(blackScholesPrice())
    paste("Option Price (Black-Scholes Model):", round(blackScholesPrice(), 2))
  })
}

# Run the Application
shinyApp(ui = ui, server = server)
