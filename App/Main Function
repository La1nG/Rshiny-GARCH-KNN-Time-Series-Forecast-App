library(shiny)
library(shinythemes)
library(plotly)
library(quantmod)
library(rugarch)
library(rmgarch)  # For DCC modeling
library(PerformanceAnalytics)
library(caret)
library(zoo)
library(FNN)


# Server Section
server <- function(input, output, session) {
  # Fetch Stock Data (Multivariate)
  stockData <- eventReactive(input$analyze, {
    req(input$ticker, input$daterange)
    tryCatch({
      getSymbols(input$ticker, src = "yahoo",
                 from = input$daterange[1],
                 to = input$daterange[2],
                 auto.assign = TRUE)
      na.omit(do.call(merge, lapply(input$ticker, function(x) Cl(get(x)))))
    }, error = function(e) {
      showNotification("Data fetch failed. Check inputs.", type = "error")
      NULL
    })
  })
  
  # Compute and store the returns from the first asset
  returnsData <- reactive({
    req(stockData())
    
    tryCatch({
      prices <- Cl(stockData())[,1]
      returns <- diff(log(prices))
      returns <- na.omit(returns)
      
      if (any(is.infinite(returns)) || any(is.nan(returns))) {
        showNotification("Invalid returns data detected", type = "error")
        return(NULL)
      }
      
      if (sd(returns, na.rm = TRUE) < 1e-6) {
        showNotification("Asset shows no volatility (flat prices)", 
                         type = "error")
        return(NULL)
      }
      
      returns
    }, error = function(e) {
      showNotification("Returns calculation failed", type = "error")
      NULL
    })
  })
  
   # GARCH Model (Univariate) using the reactive specification
  garchSpec <- reactive({
    req(input$garch_model)
    spec <- ugarchspec(
      variance.model = list(model = input$garch_model, garchOrder = c(1,1)),
      mean.model = list(armaOrder = c(0,0)),
      distribution.model = "std"
    )
    spec
  })
  
  garchModel <- reactive({
    req(returnsData(), garchSpec())
    tryCatch({
      ugarchfit(spec = garchSpec(), data = returnsData(),
                solver = "solnp", 
                solver.control = list(trace = 0, maxit = 5000))
    }, error = function(e) {
      showNotification(paste("GARCH fit failed:", e$message), type = "error")
      NULL
    })
  })
  
  # DCC Model (Multivariate)
  dccModel <- reactive({
    req(stockData(), input$garch_model)
    if (length(input$ticker) < 2) {
      showNotification("DCC model requires at least two assets.", type = "error")
      return(NULL)
    }
    
    returns <- na.omit(apply(stockData(), 2, function(x) diff(log(x))))
    
    # GARCH specification for each asset without solver parameters
    garch_spec <- lapply(1:ncol(returns), function(x) {
      tryCatch({
        ugarchspec(variance.model = list(model = input$garch_model, 
                                         garchOrder = c(1,1)),
                   distribution.model = "std")
      }, error = function(e) {
        showNotification(paste("GARCH spec failed for asset", x), type = "error")
        NULL
      })
    })
    
    if (any(sapply(garch_spec, is.null))) {
      return(NULL)
    }
    
    dcc_spec <- dccspec(multispec(garch_spec), VAR = FALSE, model = "DCC")
    tryCatch({
      dccfit(dcc_spec, data = returns)
    }, error = function(e) {
      showNotification(paste("DCC fit failed:", e$message), type = "error")
      NULL
    })
  })
  
  # Historical Risk Measures using the stored returns data and reactive spec
  rollRisk <- reactive({
    req(returnsData(), garchSpec(), input$window)
    
    model_data <- returnsData()
    data_length <- length(model_data)
    
    if (input$window < 30 || input$window >= data_length) {
      showNotification(paste("Invalid window size. Must be between 30 and", data_length - 1), 
                       type = "error")
      return(NULL)
    }
    
    tryCatch({
      ugarchroll(
        spec = garchSpec(),
        data = model_data,
        forecast.length = data_length - input$window,
        refit.every = 5,
        refit.window = "moving",
        VaR.alpha = 0.05,
        solver = "hybrid",
        solver.control = list(
          tol = 1e-6,       
          delta = 1e-4,
          maxit = 10000,    
          inner.tol = 1e-4
        ),
        calculate.VaR = TRUE,
        calculate.ES = TRUE
      )
    }, error = function(e) {
      showNotification(paste("Rolling forecast failed:", e$message), type = "error")
      NULL
    })
  })
  
  # GARCH Forecast
  output$modelSummary <- renderPrint({
    if (!is.null(garchModel())) show(garchModel()) else "Model unavailable"
  })
  
  output$garchForecastPlot <- renderPlotly({
    req(garchModel())
    fit <- garchModel()
    forecast <- ugarchforecast(fit, n.ahead = 30)
    vol_forecast <- sigma(forecast)^2
    
    forecast_dates <- seq(from = Sys.Date() + 1, by = "day", length.out = 30)
    
    plot_ly(x = forecast_dates, y = vol_forecast, type = "scatter", mode = "lines", name = "GARCH Forecast") %>%
      layout(title = "GARCH Forecast",
             xaxis = list(title = "Date"),
             yaxis = list(title = "Variance"),
             showlegend = TRUE)
  })
  
  # DCC Output
  output$dccPlot <- renderPlotly({
    req(dccModel())
    corr <- rcor(dccModel())[,,dim(rcor(dccModel()))[3]]
    plot_ly(z = corr, type = "heatmap", 
            x = input$ticker, y = input$ticker) %>%
      layout(title = "Dynamic Conditional Correlations")
  })
  
  # Historical Risk Output
  output$historicalRiskPlot <- renderPlotly({
    req(rollRisk())
    forecast_obj <- rollRisk()
    
    tryCatch({
      # Debugging: Print available elements
      print("Forecast Object Structure:")
      print(str(forecast_obj@forecast))
      
      # Check available column names
      print("Available VaR columns:")
      print(colnames(forecast_obj@forecast$VaR))
      
      # Extract VaR column dynamically
      available_var_cols <- colnames(forecast_obj@forecast$VaR)
      
      if (length(available_var_cols) == 0) {
        stop("VaR column not found in forecast object.")
      }
      
      VaR_col_name <- available_var_cols[1]  # Use the first available column
      
      forecast_dates <- as.Date(rownames(forecast_obj@forecast$VaR))
      realized_returns <- forecast_obj@forecast$VaR$realized
      VaR_values <- forecast_obj@forecast$VaR[, VaR_col_name]
      
      valid_indices <- which(!is.na(VaR_values) & !is.na(realized_returns))
      
      if (length(valid_indices) < 2) {
        showNotification("Not enough data points to display a line.", type = "warning")
        return(plot_ly() %>% layout(title = "Insufficient Data"))
      }
      
      df <- data.frame(
        Date = forecast_dates[valid_indices],
        VaR = as.numeric(VaR_values[valid_indices]),
        Realized = as.numeric(realized_returns[valid_indices])
      )
      
      # Compute Expected Shortfall (ES) manually
      df$ES <- sapply(seq_along(df$Date), function(i) {
        lower_returns <- df$Realized[df$Realized < df$VaR[i]]
        if (length(lower_returns) > 0) {
          return(mean(lower_returns))
        } else {
          return(NA)  # No ES if no values below VaR
        }
      })
      
      df <- df[complete.cases(df), ]  # Remove rows with NA values
      
      # Plotly
      plot_ly(df, x = ~Date) %>%
        add_trace(y = ~VaR, 
                  type = "scatter", 
                  mode = "lines+markers",
                  name = "VaR",
                  line = list(color = "red")) %>%
        add_trace(y = ~ES, 
                  type = "scatter", 
                  mode = "lines+markers",
                  name = "Expected Shortfall (ES)",
                  line = list(color = "blue", dash = "dot")) %>%
        layout(
          title = "Historical VaR & Expected Shortfall",
          xaxis = list(title = "Date"),
          yaxis = list(title = "Risk Metrics"),
          showlegend = TRUE
        )
      
    }, error = function(e) {
      showNotification(paste("Error:", e$message), type = "error")
      return(plot_ly() %>% layout(title = "Error in Plotting"))
    })
  })


  # VaR Calculation
  calculateVaR <- reactive({
    req(garchModel(), input$garch_model)
    alpha <- 0.05
    df <- coef(garchModel())["shape"]
    sigma_val <- sigma(garchModel())
    mu <- fitted(garchModel())
    
    if (input$garch_model == "gjrGARCH") {
      # Adjust for leverage effects
      gamma <- coef(garchModel())["gamma1"]
      sigma_val <- sigma_val * (1 + gamma/2)
    }
    
    VaR <- mu + sigma_val * qt(alpha, df = df)
    mean(VaR)
  })
  
  # Calculate Sharpe Ratio
  calculateSharpeRatio <- reactive({
    req(stockData())
    returns <- na.omit(diff(log(Cl(stockData()))))
    risk_free_rate <- 0.02
    daily_risk_free <- risk_free_rate / 252
    excess_returns <- returns - daily_risk_free
    mean_excess <- mean(excess_returns)
    volatility <- sd(excess_returns)
    sharpe_ratio <- mean_excess / volatility
    annualised_sharpe_ratio <- sharpe_ratio * sqrt(252)
    annualised_sharpe_ratio
  })
  
  # ES Calculation
  calculateES <- reactive({
    req(garchModel())
    alpha <- 0.05
    df <- coef(garchModel())["shape"]
    t_quantile <- qt(alpha, df = df)
    ES <- (dt(t_quantile, df)/alpha) * (df + t_quantile^2)/(df - 1)
    mean(ES)
  })
  
  output$varResult <- renderText({
    paste("1-Day 95% VaR:", round(calculateVaR(), 4))
  })
  
  output$esResult <- renderText({
    paste("1-Day 95% ES:", round(calculateES(), 4))
  })
  
  # Price Forecast Output
  output$forecastPlot <- renderPlotly({
    req(stockData(), garchModel())
    fit <- garchModel()
    forecast <- ugarchforecast(fit, n.ahead = 30)
    vol_forecast <- sigma(forecast)
    mu <- coef(fit)["mu"]
    last_close <- as.numeric(tail(stockData()[,1], 1))
    
    # Use sapply to simulate returns with day-specific volatility
    simulated_returns <- sapply(1:30, function(i) rnorm(1, mean = mu, sd = vol_forecast[i]))
    forecast_prices <- last_close * exp(cumsum(simulated_returns))
    
    plot_ly(x = 1:30, y = forecast_prices, type = "scatter", mode = "lines") %>%
      layout(title = "Price Forecast", xaxis = list(title = "Days Ahead"))
  })
  
  # RMSE vs K Plot
  output$rmsePlot <- renderPlotly({
    req(stockData())
    returns <- na.omit(diff(log(Cl(stockData()))))
    set.seed(42)
    trainIndex <- createDataPartition(returns, p = 0.8, list = FALSE)
    train <- returns[trainIndex]
    test <- returns[-trainIndex]
    
    rmse_values <- sapply(1:input$k, function(k) {
      model <- knn.reg(train = train, test = test, y = train, k = k)
      sqrt(mean((model$pred - test)^2))
    })
    plot_ly(x = 1:input$k, y = rmse_values, type = "scatter", mode = "lines", name = "RMSE vs K") %>%
      layout(title = "RMSE vs K for K-NN", xaxis = list(title = "Number of Neighbors (K)"), yaxis = list(title = "RMSE"))
  })
  
  output$sharpeRatioResult <- renderText({
    req(calculateSharpeRatio())
    paste("Sharpe Ratio:", round(calculateSharpeRatio(), 2))
  })
}

shinyApp(ui = ui, server = server)
