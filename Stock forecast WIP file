### This file is to hold a WIP for the stock price forecasting section ###




library(reticulate)
library(shiny)
library(shinydashboard)
library(plotly)
library(forecast)
library(bsts)
library(DT)
library(tidyverse)
library(lubridate)
library(quantmod)
library(Metrics)
library(bizdays)
library(TTR)
library(zoo)
library(fredr)

source("app.r") # Improved Data Acquisition & Preprocessing Module

torch <- import("torch")
nn <- import("torch.nn")
optim <- import("torch.optim")

define_seq2seq_lstm_model <- function(input_size, hidden_size, output_steps) {
  py_run_string(glue::glue("
import torch.nn as nn
class Seq2SeqLSTM(nn.Module):
    def __init__(self):
        super(Seq2SeqLSTM, self).__init__()
        self.lstm = nn.LSTM(input_size={input_size}, hidden_size={hidden_size}, batch_first=True)
        self.fc = nn.Linear({hidden_size}, {output_steps})

    def forward(self, x):
        out, _ = self.lstm(x)
        out = self.fc(out[:, -1, :])
        return out

model = Seq2SeqLSTM()"))
  return(py$model)
}

normalize_series <- function(series) {
  min_val <- min(series, na.rm = TRUE)
  max_val <- max(series, na.rm = TRUE)
  scaled <- (series - min_val) / (max_val - min_val)
  list(scaled = scaled, min_val = min_val, max_val = max_val)
}

denormalize_series <- function(scaled_values, min_val, max_val) {
  scaled_values * (max_val - min_val) + min_val
}

calculate_metrics <- function(actual, predicted) {
  list(RMSE = rmse(actual, predicted), MAPE = mape(actual, predicted))
}

forecast_seq2seq_lstm_with_metrics <- function(series, h, input_size = 1, hidden_size = 128, window_size = 30, epochs = 500, patience = 20, learning_rate = 0.0005) {
  series <- as.numeric(series)
  series_len <- length(series)
  
  if (series_len <= window_size + h) {
    stop("Series length must be greater than window size + forecast horizon (h).")
  }
  
  train_size <- series_len - h
  train_series <- series[1:train_size]
  test_series <- series[(train_size + 1):series_len]
  
  norm <- normalize_series(train_series)
  price_tensor <- torch$tensor(norm$scaled, dtype = torch$float32)
  
  X_train <- list()
  y_train <- list()
  
  for (i in 1:(train_size - window_size - h + 1)) {
    X_train[[i]] <- price_tensor[(i - 1):(i + window_size - 2)]$unsqueeze(1L)
    y_train[[i]] <- price_tensor[(i + window_size - 1):(i + window_size + h - 1)]
  }
  
  X_price_tensor <- torch$stack(X_train)
  y_price_tensor <- torch$stack(y_train)
  
  model <- define_seq2seq_lstm_model(input_size, hidden_size, h)
  criterion <- nn$MSELoss()
  optimizer <- optim$Adam(model$parameters(), lr = learning_rate)
  
  loss_values <- numeric(epochs)
  best_loss <- Inf
  epochs_no_improve <- 0
  
  for (epoch in 1:epochs) {
    optimizer$zero_grad()
    output <- model(X_price_tensor)
    loss <- criterion(output, y_price_tensor)
    loss$backward()
    optimizer$step()
    
    loss_values[epoch] <- loss$item()
    if (loss$item() < best_loss) {
      best_loss <- loss$item()
      epochs_no_improve <- 0
    } else {
      epochs_no_improve <- epochs_no_improve + 1
    }
    
    if (epochs_no_improve >= patience) {
      loss_values <- loss_values[1:epoch]
      break
    }
  }
  
  input_seq <- price_tensor[(train_size - window_size + 1):train_size]
  input_tensor <- input_seq$unsqueeze(1L)$unsqueeze(0L)
  
  preds_tensor <- torch$no_grad()$enter({
    model(input_tensor)
  })
  
  preds <- as.numeric(preds_tensor$detach()$cpu()$numpy())
  final_predictions <- denormalize_series(preds, norm$min_val, norm$max_val)
  
  metrics <- calculate_metrics(test_series, final_predictions)
  
  list(predictions = final_predictions, loss_values = loss_values, metrics = metrics)
}

ui <- dashboardPage(
  dashboardHeader(title = "Asset Forecasting App"),
  dashboardSidebar(
    textInput("symbol", "Symbols (comma-separated)", "AAPL"),
    selectInput("asset_type", "Asset Type", choices = c("stock", "forex", "crypto", "commodity", "index")),
    dateInput("start_date", "Start Date", value = Sys.Date() - years(3)),
    dateInput("end_date", "End Date", value = Sys.Date()),
    numericInput("forecast_days", "Forecast Days", 30, min = 1, max = 365),
    numericInput("epochs", "Epochs", 500, min = 1),
    numericInput("hidden_size", "Hidden Size", 128, min = 1),
    numericInput("window_size", "Window Size", 30, min = 1),
    actionButton("fetch_data", "Fetch Data"),
    actionButton("run_forecast", "Run Forecast")
  ),
  dashboardBody(
    fluidRow(
      box(plotlyOutput("forecastPlot"), width = 12),
      box(dataTableOutput("table"), width = 12),
      box(plotlyOutput("lossPlot"), width = 12),
      box(dataTableOutput("metricsTable"), width = 12)
    )
  )
)

server <- function(input, output, session) {
  data <- reactiveVal(NULL)
  forecast_results <- reactiveVal(NULL)
  
  observeEvent(input$fetch_data, {
    symbols <- strsplit(input$symbol, ",")[[1]] %>% trimws()
    
    fetched_data <- lapply(symbols, function(sym) {
      process_asset_data(sym, input$asset_type, input$start_date, input$end_date)
    })
    
    combined_data <- bind_rows(fetched_data)
    data(combined_data)
  })
  
  observeEvent(input$run_forecast, {
    df <- data()
    req(df)
    
    cal <- bizdays::create.calendar(
      name = "Forex",
      weekdays = c("saturday", "sunday")
    )
    
    forecasts <- lapply(unique(df$Symbol), function(sym) {
      symbol_df <- df %>% filter(Symbol == sym)
      price_series <- ts(symbol_df$Price, frequency = 365)
      
      h <- input$forecast_days
      train_size <- length(price_series) - h
      train_series <- price_series[1:train_size]
      test_series <- price_series[(train_size + 1):length(price_series)]
      
      lstm_result <- forecast_seq2seq_lstm_with_metrics(
        train_series,
        h,
        hidden_size = input$hidden_size,
        window_size = input$window_size,
        epochs = input$epochs
      )
      
      arima_model <- auto.arima(train_series)
      arima_forecast <- forecast(arima_model, h = h)
      arima_metrics <- calculate_metrics(test_series, as.numeric(arima_forecast$mean))
      
      state_spec <- AddLocalLinearTrend(list(), train_series)
      bsts_model <- bsts(train_series, state.specification = state_spec, niter = 1000)
      bsts_forecast <- predict(bsts_model, horizon = h)
      bsts_metrics <- calculate_metrics(test_series, as.numeric(bsts_forecast$mean))
      
      hybrid_forecast <- (lstm_result$predictions + as.numeric(arima_forecast$mean) + as.numeric(bsts_forecast$mean)) / 3
      hybrid_metrics <- calculate_metrics(test_series, hybrid_forecast)
      
      list(
        LSTM = lstm_result,
        ARIMA = arima_metrics,
        BSTS = bsts_metrics,
        Hybrid = hybrid_metrics
      )
    })
    
    forecast_results(forecasts)
  })
}

shinyApp(ui, server)
